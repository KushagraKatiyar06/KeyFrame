#Amazon polly will be used to convert text generated by open ai into speeches 
import os
import tempfile
import boto3
from botocore.exceptions import BotoCoreError, ClientError
import subprocess


def _get_audio_duration_mutagen(path):
    try:
        from mutagen.mp3 import MP3
        audio = MP3(path)
        return audio.info.length
    except Exception:
        return None


def _get_audio_duration_ffprobe(path):
    try:
        cmd = [
            'ffprobe', '-v', 'error', '-select_streams', 'a:0', '-show_entries',
            'stream=duration', '-of', 'default=noprint_wrappers=1:nokey=1', path
        ]
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        return float(result.stdout.strip())
    except Exception:
        return None


def get_audio_duration(path):
    d = _get_audio_duration_mutagen(path)
    if d is not None:
        return d
    return _get_audio_duration_ffprobe(path)


def generate_voice_over(script_data, job_id):
    """Generate voiceover per-slide using Amazon Polly.

    Produces one MP3 file per slide, measures durations, concatenates into a single
    `voiceover_full.mp3` and returns (full_audio_path, slide_durations).
    This avoids large SSML payloads and enables accurate timings for each image.
    """
    temp_dir = os.path.join(tempfile.gettempdir(), f'keyframe_job_{job_id}')
    os.makedirs(temp_dir, exist_ok=True)

    polly_client = boto3.client(
        'polly',
        aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
        aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
        region_name=os.getenv('AWS_REGION', 'us-east-1')
    )

    slides = script_data.get('slides', [])
    slide_paths = []
    slide_durations = []

    try:
        for i, slide in enumerate(slides):
            narration = slide.get('narration', '') or ''
            # Use plain text voice synthesis per-slide to avoid SSML parsing errors.
            print(f"Polly: synthesizing slide {i+1}/{len(slides)} ({len(narration)} chars)")

            response = polly_client.synthesize_speech(
                Text=narration,
                TextType='text',
                OutputFormat='mp3',
                VoiceId=os.getenv('POLLY_VOICE', 'Joanna'),
                Engine='standard'
            )

            audio_stream = response.get('AudioStream')
            if not audio_stream:
                raise Exception(f"No audio stream returned for slide {i}")

            slide_mp3 = os.path.join(temp_dir, f'slide_{i}.mp3')
            with open(slide_mp3, 'wb') as f:
                f.write(audio_stream.read())

            slide_paths.append(slide_mp3)

            # measure duration
            duration = get_audio_duration(slide_mp3)
            if duration is None:
                raise Exception(f"Could not determine duration for {slide_mp3}")

            slide_durations.append(float(duration))
            print(f"Slide {i+1} duration: {duration:.2f}s")

        # concatenate slide mp3s into one file using ffmpeg concat demuxer
        concat_list = os.path.join(temp_dir, 'audio_concat.txt')
        with open(concat_list, 'w', encoding='utf-8') as f:
            for p in slide_paths:
                f.write(f"file '{p}'\n")

        full_audio = os.path.join(temp_dir, 'voiceover_full.mp3')
        FFMPEG = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'bin', 'ffmpeg.exe'))

        cmd = [
            FFMPEG,
            '-y',
            '-f', 'concat',
            '-safe', '0',
            '-i', concat_list,
            '-c', 'copy',
            full_audio
        ]

        print("Concatenating slide audio into full voiceover...")
        subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)

        # final sanity check
        if not os.path.exists(full_audio):
            raise Exception("Failed to create concatenated voiceover file")

        total = sum(slide_durations)
        print(f"Voiceover created: {full_audio} (total {total:.2f}s)")

        return full_audio, slide_durations

    except (BotoCoreError, ClientError) as e:
        print(f"Polly error: {e}")
        raise
    except subprocess.CalledProcessError as e:
        print(f"FFmpeg error while concatenating audio: {e.stderr}")
        raise
    except Exception as e:
        print(f"Unexpected error in voice_over: {e}")
        raise