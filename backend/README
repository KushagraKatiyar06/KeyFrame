# ⚙️ KeyFrame Backend Services

This directory contains the backend pieces for the KeyFrame video generation pipeline: the **Node.js API Gateway** (`backend/api`) and the **Python worker** (`backend/worker`) that performs script generation, image/TTS generation, and assembly.

The README below keeps the existing notes but adds concrete, copy-paste setup items you can use to get a local dev environment running quickly.

---

## 1) Quick checklist (minimum to run locally)

- Install Node.js (v18+) and Python (3.10+)
- Docker (optional but recommended) or run Redis and Postgres locally
- Place `ffmpeg`/`ffprobe` in `./bin/` or ensure they are installed on the PATH
- Create a `.env` (see `.env.example`) with API keys and DB/Redis URIs
- Install Node deps in `backend/api` and Python deps in `backend/worker`

## 2) `.env.example` (place as `backend/.env.example` - copy to `.env` and populate)

```
# Redis
REDIS_URL=redis://localhost:6379

# Database
DATABASE_URL=postgresql://keyframe_user:password@localhost:5432/keyframe_db

# Backend HTTP
PORT=3001
BACKEND_URL=http://localhost:3001

# Local output folder for job artifacts
KEYFRAME_OUTPUT_DIR=C:\\tmp

# FFmpeg override (optional)
FFMPEG_PATH=./bin/ffmpeg.exe
FFPROBE_PATH=./bin/ffprobe.exe

# Third-party API keys (fill when required)
OPENAI_API_KEY=
NEBIUS_API_KEY=
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=us-east-1
POLLY_VOICE=Joanna

# Cloudflare R2 (optional)
R2_ACCOUNT_ID=
R2_ACCESS_KEY=
R2_SECRET_KEY=
R2_BUCKET=
```

## 3) Quick Docker Compose (start Redis/Postgres locally)

If you don't want to install Redis/Postgres system-wide, create a `docker-compose.yml` in the repo root with the following services and run `docker compose up -d`:

```
version: '3.8'
services:
	redis:
		image: redis:7
		ports:
			- "6379:6379"

	postgres:
		image: postgres:15
		environment:
			POSTGRES_USER: keyframe_user
			POSTGRES_PASSWORD: password
			POSTGRES_DB: keyframe_db
		ports:
			- "5432:5432"
		volumes:
			- pgdata:/var/lib/postgresql/data

volumes:
	pgdata:
```

## 4) FFmpeg (Windows guidance)

- Recommended: put `ffmpeg.exe` and `ffprobe.exe` in `./bin/` at the repository root.
- Verify: `./bin/ffmpeg.exe -version` and `./bin/ffprobe.exe -version` or add `./bin` to your PATH.

## 5) Install & run (local, non-Docker)

Backend API

```powershell
cd backend/api
npm install
set PORT=3001
node index.js
```

Python worker (Windows recommended steps)

```powershell
cd backend/worker
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install -r requirements.txt
# Run Celery worker (Windows: use --pool=solo)
set REDIS_URL=redis://localhost:6379
celery -A app worker --loglevel=info --pool=solo
```

Note: `--pool=solo` is required on Windows to avoid multiprocessing errors in Celery.

## 6) How the pieces fit

- `backend/api` exposes HTTP routes used by the frontend: `/api/v1/generate`, `/api/v1/status/:jobId`, `/api/v1/feed`.
- `backend/worker` listens for jobs (pushed to Redis) and runs `orchestrator.process_video_job` which produces images, TTS, assembles with FFmpeg, and writes outputs to `KEYFRAME_OUTPUT_DIR` and to `backend/api/public/videos/{jobId}`.

## 7) Notes about ports / dev ergonomics

- The frontend dev server defaults to port `3000` (Next.js). To avoid a conflict, the backend defaults to port `3001` (see `.env.example`). Adjust `PORT` if you prefer different ports.

## 8) Troubleshooting (common issues)

- `FileNotFoundError: ... ffmpeg.exe` — worker cannot find ffmpeg. Confirm `FFMPEG_PATH` in `.env` or that `./bin/ffmpeg.exe` exists.
- `PermissionError` with Celery on Windows — run worker with `--pool=solo`.
- Redis connection issues — ensure `REDIS_URL` is correct and Redis is running (or `docker compose up redis`).
- DB migrations / schema — `backend/api` will attempt to create the `videos` table on startup; verify DB credentials in `DATABASE_URL`.

---
